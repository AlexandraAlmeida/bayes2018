---
title: "Time Series Analysis in Stan"
author: "Kazuki Yoshida"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output: html_document
---

```{r, message = FALSE, tidy = FALSE, echo = F}
## knitr configuration: http://yihui.name/knitr/options#chunk_options
library(knitr)
showMessage <- FALSE
showWarning <- TRUE
set_alias(w = "fig.width", h = "fig.height", res = "results")
opts_chunk$set(comment = "##", error= TRUE, warning = showWarning, message = showMessage,
               tidy = FALSE, cache = FALSE, echo = TRUE,
               fig.width = 7, fig.height = 7, dev.args = list(family = "sans"))
## for rgl
## knit_hooks$set(rgl = hook_rgl, webgl = hook_webgl)
## for animation
opts_knit$set(animation.fun = hook_ffmpeg_html)
## R configuration
options(width = 116, scipen = 5)
## Record start time
start_time <- Sys.time()
## Configure parallelization
## Parallel backend for foreach (also loads foreach and parallel; includes doMC)
library(doParallel)
## Reproducible parallelization
library(doRNG)
## Detect core count (Do not use on clusters)
n_cores <- parallel::detectCores()
## Used by parallel::mclapply() as default
options(mc.cores = n_cores)
## Used by doParallel as default
options(cores = n_cores)
## Register doParallel as the parallel backend for foreach
## http://stackoverflow.com/questions/28989855/the-difference-between-domc-and-doparallel-in-r
doParallel::registerDoParallel(cores = n_cores)
```

## References
- Online
  - [Stan Leukemia example](https://github.com/stan-dev/example-models/blob/master/bugs_examples/vol1/leuk/leuk.stan)
  - [Stan for survival models](https://discourse.mc-stan.org/t/stan-for-survival-models/4146)
  - [PyMC3 Bayesian Survival Analysis](https://docs.pymc.io/notebooks/survival_analysis.html)
  - [Piece-Wise Exponential Model](http://data.princeton.edu/wws509/notes/c7s4.html)
  - [Stan-dev Prior Choice Recommendations](https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations)
- Books
  - [(BUGS) The BUGS Book: A Practical Introduction to Bayesian Analysis](https://www.mrc-bsu.cam.ac.uk/software/bugs/the-bugs-project-the-bugs-book/) 11.2 Time series models


## Load packages
```{r}
library(tidyverse)
library(rstan)
library(bayesplot)
```

## Load data
```{r}
data("sunspot.year", package = "datasets")
sunspot.year
sunspot_year <- tibble(sun_spot = as.numeric(sunspot.year),
                       year = as.integer(time(sunspot.year)))
sunspot_year
```

## AR(1) Model
### Stan code
```{r}
ar_p_stan <- rstan::stan_model("./bugs_time_series_ar_p.stan")
ar_p_stan
```
### Stan fit
```{r, results = "hide"}
ar_1_stan_fit <-
    rstan::sampling(ar_p_stan,
                    data = list(p = 1,
                                init_mean = as.array(c(0)),
                                init_sd = as.array(c(100)),
                                theta_mean = as.array(c(0)),
                                theta_sd = as.array(c(100)),
                                sigma_mean = 0,
                                sigma_sd = 100,
                                ##
                                N = length(sunspot.year),
                                y = as.numeric(sunspot.year),
                                yr = as.integer(time(sunspot.year))))
```
### Diagnostics
Diagnostics indicate the HMC sampler behaved nicely.
```{r}
## Print a summary for a fitted model represented by a 'stanfit' object
print(ar_1_stan_fit, pars = c("theta","sigma","lp__"))
## Check HMC diagnostics after sampling
rstan::check_hmc_diagnostics(ar_1_stan_fit)
## Create a matrix of output plots from a 'stanfit' object
pairs(ar_1_stan_fit, pars = c("theta","sigma","lp__"))
## Explicity specify HMC diagnostics
bayesplot::mcmc_scatter(as.array(ar_1_stan_fit),
                        regex_pars = c("theta", "sigma"),
                        transform = list("sigma" = log),
                        np = nuts_params(ar_1_stan_fit))
## Markov chain traceplots
rstan::traceplot(ar_1_stan_fit, pars = c("theta","sigma","lp__"), inc_warmup = FALSE)
## Trace plots of MCMC draws
## ‘mcmc_rank_hist()’ Whereas traditional trace plots visualize how
##      the chains mix over the course of sampling, rank histograms
##      visualize how the values from the chains mix together in
##      terms of ranking. An ideal plot would show the rankings
##      mixing or overlapping in a uniform distribution. See Vehtari
##      et al. (2019) for details.
bayesplot::mcmc_rank_hist(ar_1_stan_fit, regex_pars = c("theta", "sigma"), ref_line = TRUE)
bayesplot::mcmc_rank_overlay(ar_1_stan_fit, regex_pars = c("theta", "sigma"), ref_line = TRUE)
bayesplot::mcmc_trace_highlight(ar_1_stan_fit, regex_pars = c("theta", "sigma"), highlight = 1)
```
### Posterior predictive checks
Posterior predictive checks indicate there are missed features.
```{r}
y_rep <- as.matrix(ar_1_stan_fit, pars = "y_rep")
## Density overlay
ppc_dens_overlay(y = as.numeric(sunspot.year),
                 yrep = y_rep[sample(seq_len(nrow(y_rep)), size = 200), ])
## Interval
ppc_intervals(y = as.numeric(sunspot.year),
              yrep = y_rep[sample(seq_len(nrow(y_rep)), size = 200), ],
              x = as.integer(time(sunspot.year)),
              prob = 0.5)
## Quantiles
ppc_stat(y = as.numeric(sunspot.year),
         yrep = y_rep,
         stat = function(y) {quantile(y, probs = 0.25)}) +
    labs(title = "25th Percentile")
ppc_stat(y = as.numeric(sunspot.year),
         yrep = y_rep,
         stat = function(y) {quantile(y, probs = 0.75)}) +
    labs(title = "75th Percentile")
```

## AR(2) model
### Stan fit
```{r, results = "hide"}
ar_2_stan_fit <-
    rstan::sampling(ar_p_stan,
                    data = list(p = 2,
                                init_mean = c(0,0),
                                init_sd = c(100,100),
                                theta_mean = c(0,0),
                                theta_sd = c(100,100),
                                sigma_mean = 0,
                                sigma_sd = 100,
                                ##
                                N = length(sunspot.year),
                                y = as.numeric(sunspot.year),
                                yr = as.integer(time(sunspot.year))))
```
### Diagnostics
Diagnostics indicate the HMC sampler behaved nicely. However, we observe that two theta parameters are correlated, which may be improved by reparametrization.
```{r}
## Print a summary for a fitted model represented by a 'stanfit' object
print(ar_2_stan_fit, pars = c("theta","sigma","lp__"))
## Check HMC diagnostics after sampling
rstan::check_hmc_diagnostics(ar_2_stan_fit)
## Create a matrix of output plots from a 'stanfit' object
pairs(ar_2_stan_fit, pars = c("theta","sigma","lp__"))
## Explicity specify HMC diagnostics
bayesplot::mcmc_scatter(as.array(ar_2_stan_fit),
                        pars = c("theta[1]", "theta[2]"),
                        np = nuts_params(ar_2_stan_fit))
## Markov chain traceplots
rstan::traceplot(ar_2_stan_fit, pars = c("theta","sigma","lp__"), inc_warmup = FALSE)
## Trace plots of MCMC draws
## ‘mcmc_rank_hist()’ Whereas traditional trace plots visualize how
##      the chains mix over the course of sampling, rank histograms
##      visualize how the values from the chains mix together in
##      terms of ranking. An ideal plot would show the rankings
##      mixing or overlapping in a uniform distribution. See Vehtari
##      et al. (2019) for details.
bayesplot::mcmc_rank_hist(ar_2_stan_fit, regex_pars = c("theta", "sigma"), ref_line = TRUE)
bayesplot::mcmc_rank_overlay(ar_2_stan_fit, regex_pars = c("theta", "sigma"), ref_line = TRUE)
bayesplot::mcmc_trace_highlight(ar_2_stan_fit, regex_pars = c("theta", "sigma"), highlight = 1)
```
### Posterior predictive checks
Posterior predictive checks still indicate there are missed features.
```{r}
y_rep <- as.matrix(ar_2_stan_fit, pars = "y_rep")
## Density overlay
ppc_dens_overlay(y = as.numeric(sunspot.year),
                 yrep = y_rep[sample(seq_len(nrow(y_rep)), size = 200), ])
## Interval
ppc_intervals(y = as.numeric(sunspot.year),
              yrep = y_rep[sample(seq_len(nrow(y_rep)), size = 200), ],
              x = as.integer(time(sunspot.year)),
              prob = 0.5)
## Quantiles
ppc_stat(y = as.numeric(sunspot.year),
         yrep = y_rep,
         stat = function(y) {quantile(y, probs = 0.25)}) +
    labs(title = "25th Percentile")
ppc_stat(y = as.numeric(sunspot.year),
         yrep = y_rep,
         stat = function(y) {quantile(y, probs = 0.75)}) +
    labs(title = "75th Percentile")
```


--------------------
- Top Page: http://rpubs.com/kaz_yos/
- Github: https://github.com/kaz-yos

```{r}
print(sessionInfo())
## Record execution time and multicore use
end_time <- Sys.time()
diff_time <- difftime(end_time, start_time, units = "auto")
cat("Started  ", as.character(start_time), "\n",
    "Finished ", as.character(end_time), "\n",
    "Time difference of ", diff_time, " ", attr(diff_time, "units"), "\n",
    "Used ", foreach::getDoParWorkers(), " cores\n",
    "Used ", foreach::getDoParName(), " as backend\n",
    sep = "")
```
