---
title: "Bayesian Survival Analysis"
author: "Kazuki Yoshida"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output: html_document
---

```{r, message = FALSE, tidy = FALSE, echo = F}
## knitr configuration: http://yihui.name/knitr/options#chunk_options
library(knitr)
showMessage <- FALSE
showWarning <- TRUE
set_alias(w = "fig.width", h = "fig.height", res = "results")
opts_chunk$set(comment = "##", error= TRUE, warning = showWarning, message = showMessage,
               tidy = FALSE, cache = F, echo = T,
               fig.width = 7, fig.height = 7, dev.args = list(family = "sans"))
## for rgl
## knit_hooks$set(rgl = hook_rgl, webgl = hook_webgl)
## for animation
opts_knit$set(animation.fun = hook_ffmpeg_html)

## R configuration
options(width = 116, scipen = 5)

## Configure parallelization
## Parallel backend for foreach (also loads foreach and parallel; includes doMC)
library(doParallel)
## Reproducible parallelization
library(doRNG)
## Detect core count (Do not use on clusters)
n_cores <- parallel::detectCores()
## Used by parallel::mclapply() as default
options(mc.cores = n_cores)
## Used by doParallel as default
options(cores = n_cores)
## Register doParallel as the parallel backend with foreach
## http://stackoverflow.com/questions/28989855/the-difference-between-domc-and-doparallel-in-r
doParallel::registerDoParallel(cores = n_cores)
## Report multicore use
## cat("### Using", foreach::getDoParWorkers(), "cores\n")
## cat("### Using", foreach::getDoParName(), "as backend\n")
```

## References
- [Stan for survival models](https://discourse.mc-stan.org/t/stan-for-survival-models/4146)
- Books
-
- R packages
  - [bayesSurv: Bayesian Survival Regression with Flexible Error and Random Effects Distributions](https://cran.r-project.org/web/packages/bayesSurv/index.html)
  - [survHE: Survival Analysis in Health Economic Evaluation](https://cran.r-project.org/web/packages/survHE/index.html)
  - [biostan: Introduction to Bayesian Inference using Stan with Applications to Cancer Genomics](https://github.com/jburos/biostan)
- SurvivalStan (Python)
  - [Introducing SurvivalStan](http://www.hammerlab.org/2017/06/26/introducing-survivalstan/)
  - [Github SurvivalStan](https://github.com/hammerlab/survivalstan)


## Background
Survival analysis is at the core of epidemiological data analysis. There are multiple well-known Bayesian data analysis textbooks, but they typically do not cover survival analysis. Here we will show case some R examples of Bayesian survival analysis.


## Load packages

```{r}
library(tidyverse)
library(survminer)
library(bayesSurv)
## devtools::install_github('jburos/biostan', build_vignettes = TRUE, dependencies = TRUE)
library(biostan)
library(rstan)
library(bayesplot)
library(tidybayes)
```


## Descriptive analysis example
### Load a simple dataset

```{r}
data(leukemia, package = "survival")
leukemia <- as_data_frame(leukemia)
leukemia
```

```
aml                  package:survival                  R Documentation
Acute Myelogenous Leukemia survival data
Description:
     Survival in patients with Acute Myelogenous Leukemia.  The
     question at the time was whether the standard course of
     chemotherapy should be extended ('maintainance') for additional
     cycles.
Usage:
     aml
     leukemia
Format:
       time:    survival or censoring time
       status:  censoring status
       x:       maintenance chemotherapy given? (factor)
Source:
     Rupert G. Miller (1997), _Survival Analysis_.  John Wiley & Sons.
     ISBN: 0-471-25218-2.
```


### Regular Kaplan-Meier plot

```{r}
km_fit <- survfit(Surv(time, status) ~ x, data = leukemia)
km_fit
## http://www.sthda.com/english/wiki/survminer-0-2-4
ggsurvplot(km_fit,
           conf.int = TRUE,
           break.time.by = 20,
           risk.table = TRUE)
```

### Stan Weibull fit

Here we will use the Weibull model code available in [biostan](https://github.com/jburos/biostan).

```{r}
stan_weibull_survival_model_file <- system.file('stan', 'weibull_survival_model.stan', package =  'biostan')
biostan::print_stan_file(stan_weibull_survival_model_file)
```

Stan parameterizes this probability density function for the survival time $y$ as follows.

$$f(y|\alpha,\sigma) =
\frac{\alpha}{\sigma}\left(\frac{y}{\sigma}\right)^{\alpha-1}e^{-(y/\sigma)^{\alpha}}$$

where $\alpha$ is the shape parameter and $\sigma$ is the scale parameter. The average survival time increases with an increasing $\sigma$. To incorporate covariates, the scale parameter is defined as follows in the Stan program used here.

$$\sigma_{i} = \exp{\left( - \frac{\mu + X_{i}^{T}\beta}{\alpha} \right)}$$

As $\sigma$ is a decreasing function of $\beta$, a positive $\beta$ means a shorter average survival time with a unit increase in $X_i$ and a negative $\beta$ means a longer average survival time with a unit increase in $X_i$.

From the data block, observations where events were observed and censored are handled separately. No hyperparameters for the priors are specified here. They are hard-coded.

```{r}
stan_weibull_survival_model_code <- biostan::read_stan_file(stan_weibull_survival_model_file)
biostan::print_stan_code(stan_weibull_survival_model_code, section = "data")
```

Here we structure the data accordingly.

```{r}
stan_weibull_survival_model_data <-
    list(
        ## Number of event individuals
        Nobs = sum(leukemia$status == 1),
        ## Number of censored individuals
        Ncen = sum(leukemia$status == 0),
        ## Number of covariates
        M_bg = 1,
        ## Times for event individuals
        yobs = leukemia$time[leukemia$status == 1],
        ## Times for censored individuals
        ycen = leukemia$time[leukemia$status == 0],
        ## Covariates for event individuals as a matrix
        Xobs_bg = matrix(as.numeric(leukemia$x == "Maintained")[leukemia$status == 1]),
        ## Covariates for censored individuals as a matrix
        Xcen_bg = matrix(as.numeric(leukemia$x == "Maintained")[leukemia$status == 0])
        )
stan_weibull_survival_model_data
```

Here we fit the model.

```{r, cache = TRUE}
stan_weibull_survival_model_fit <-
    rstan::stan(file = stan_weibull_survival_model_file,
                data = stan_weibull_survival_model_data)
```

Here we check the results. The ```Rhat``` values are all around 1, indicating reasonable results for all parameters. Each element of ```yhat_uncens``` (a vector of 23 elements) is MCMC samples of event times for each individual based on $(\alpha, \sigma_{i})$ MCMC samples.

```{r}
stan_weibull_survival_model_fit
```

The traceplots for the parameters of interest appear to indicate reasonable mixing.

```{r}
rstan::traceplot(stan_weibull_survival_model_fit, par = c("alpha","mu","beta_bg"))
```

Some auto-correlation is seen for the parameters of interest.

```{r}
bayesplot::mcmc_acf(as.matrix(stan_weibull_survival_model_fit), pars = c("alpha","mu","beta_bg[1]"))
```

95% credible intervals for the parameters. The effect of interest ```beta_bg[1]``` seems to have most of its posterior probability in the negative range (survival benefit with Maintained treatment).

```{r}
bayesplot::mcmc_areas(as.matrix(stan_weibull_survival_model_fit), pars = c("alpha","mu","beta_bg[1]"), prob = 0.95)
```

The parameter values do not give intuitive understanding of the survival time distributions for each group. As the Stan code sampled the event times for each individual, we can examine these directly.

```{r}
stan_weibull_survival_model_draws <- tidybayes::tidy_draws(stan_weibull_survival_model_fit)
stan_weibull_survival_model_draws
```

The ordering of ```yhat_uncens``` does not respect the original data ordering, but is in the observed-then-censored ordering of data fed to Stan. We need to create the corresponding treatment vector.

```{r}
treatment_assignment <- c(as.numeric(leukemia$x == "Maintained")[leukemia$status == 1],
                          as.numeric(leukemia$x == "Maintained")[leukemia$status == 0])
```

The draws have to be reorganized in the long format.

```{r}
stan_weibull_survival_model_draws %>%
    select(.chain, .iteration, .draw, starts_with("yhat_uncens")) %>%
    gather(key = key, value = yhat_uncens, starts_with("yhat_uncens")) %>%
    separate(col = key, sep = "\\[", into = c("key","obs"))
```


<!-- ## Recurrent event example -->
<!-- ### Load a dataset with recurrent events -->
<!-- ```{r} -->
<!-- data(cgd, package = "bayesSurv") -->
<!-- cgd <- as_data_frame(cgd) -->
<!-- cgd -->
<!-- ``` -->


--------------------
- Top Page: http://rpubs.com/kaz_yos/
- Github: https://github.com/kaz-yos
